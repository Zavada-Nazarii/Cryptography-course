# Базові вимоги для функціоналу хешування:

1. висока безпека для слабких паролів;
2. захист від брутфорсу та інших типів атак на паролі незалежно від їх складності;
3. збереження доступності системи, а саме оптимальне навантаження з розрахунку, що систему відвідують мільйони людей, а це може спричинити велике навантаження у разі складного механізму хешування паролів;
4. підтримку довгих паролів незалежно від їх довжини.

# Обґрунтування вибору PBKDF2-HMAC-SHA256

Спочатку варіантом був метод `bcrypt`, але як згадувалось із вразливістю з `Okta` цей механізм шифрування не здатен обробити пароль більший за 72 байти, а тому `bcrypt` не підходить.

Іншим варіантом став `Argon2`, який був би досить вдалим варіантом, але він не підходить для систем які обробляють великий трафік, а тому він буде досить сильно навантажувати систему, навіть з врахуванням динамічного підходу до ентропії клієнтського паролю.

Тому, використано поєднання `PBKDF2-HMAC-SHA256`, що забезпечує наступне:

1. швидке опрацювання за раунок швидкості самого методу `PBKDF2`;
2. підтримка клієнтських паролів більших за 72 байти, використовуючи `SHA-512` перед `PBKDF2` забезпечує повноцінну ентропію для довгих паролів;
3. також, використовуємо `zxcvbn` для динамічного визначення чи клієнтський код безпечний чи складний, за рахунок його `score`, відповідно збільшуємо кількість ітерацій з урахуванням ентропії клієнтського коду. Динамічне налаштування складності;
4. використовуємо `HMAC` відповідно для кількості ітерацій, захисту від брутфорсу, унікальний `salt` для унеможливлення визначення попередньо обчислених хешів;
5. дотримано баланс між складність, безпекою та навантаження на систему.

# Проблеми у зв'язку використання `zxcvbn`

`zxcvbn` підтримує код не більше 72 символи, відповідно реалізовано сехему, за якої пароль менший за 72 символи проходить оцінку ентропії через `zxcvbn`, якщо пароль більший за 72 опрацьовуємо `SHA-512` перед `PBKDF2` і на `zxcvbn` для оцінки ентропії. Відповідно пароль опрацьований `SHA-512` перед `PBKDF2` отримав нижчу ентропію, як пароль який був менший за 72 символи і оцінений `zxcvbn`. Дана поведінка не впливає особливо на рівень безпеки, але впливає на кількість ітерацій, навіть якщо по факту клієнтський пароль має найвищу ентропію серед представлених.

# Вміст

1. [hash_passwd.py](https://github.com/Zavada-Nazarii/Cryptography-course/blob/master/lesson-5/Task%201/hash_passwd.py) скрипт для хешування паролів із файлу [passwords.txt](https://github.com/Zavada-Nazarii/Cryptography-course/blob/master/lesson-5/Task%201/passwords.txt)
2. [check_passwd.py](https://github.com/Zavada-Nazarii/Cryptography-course/blob/master/lesson-5/Task%201/check_passwd.py) скрипт для перевірки паролю із його хешом, чи хешування коректно зберігає та валідує збережений і введений користувачем пароль
3. [passwords.txt](https://github.com/Zavada-Nazarii/Cryptography-course/blob/master/lesson-5/Task%201/passwords.txt) список паролів
4. [hashed_passwords.json](https://github.com/Zavada-Nazarii/Cryptography-course/blob/master/lesson-5/Task%201/hashed_passwords.json) хешовані паролі
